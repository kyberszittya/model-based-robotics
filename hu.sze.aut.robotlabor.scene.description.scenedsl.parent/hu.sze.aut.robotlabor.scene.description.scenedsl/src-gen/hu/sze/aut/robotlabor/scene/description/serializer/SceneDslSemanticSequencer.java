/*
 * generated by Xtext 2.25.0
 */
package hu.sze.aut.robotlabor.scene.description.serializer;

import com.google.inject.Inject;
import hu.sze.aut.robot.description.scene.Box;
import hu.sze.aut.robot.description.scene.Color;
import hu.sze.aut.robot.description.scene.Cylinder;
import hu.sze.aut.robot.description.scene.ExternalModel;
import hu.sze.aut.robot.description.scene.Floor;
import hu.sze.aut.robot.description.scene.PhysicParameters;
import hu.sze.aut.robot.description.scene.Placement;
import hu.sze.aut.robot.description.scene.Rotation;
import hu.sze.aut.robot.description.scene.Scene;
import hu.sze.aut.robot.description.scene.ScenePackage;
import hu.sze.aut.robot.description.scene.Sphere;
import hu.sze.aut.robot.description.scene.Texture;
import hu.sze.aut.robot.description.scene.Vec3;
import hu.sze.aut.robot.description.scene.WallElement;
import hu.sze.aut.robotlabor.scene.description.services.SceneDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class SceneDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SceneDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ScenePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScenePackage.BOX:
				sequence_Box(context, (Box) semanticObject); 
				return; 
			case ScenePackage.COLOR:
				sequence_Color(context, (Color) semanticObject); 
				return; 
			case ScenePackage.CYLINDER:
				sequence_Cylinder(context, (Cylinder) semanticObject); 
				return; 
			case ScenePackage.EXTERNAL_MODEL:
				sequence_ExternalModel(context, (ExternalModel) semanticObject); 
				return; 
			case ScenePackage.FLOOR:
				sequence_Floor(context, (Floor) semanticObject); 
				return; 
			case ScenePackage.PHYSIC_PARAMETERS:
				sequence_PhysicParameters(context, (PhysicParameters) semanticObject); 
				return; 
			case ScenePackage.PLACEMENT:
				sequence_Placement(context, (Placement) semanticObject); 
				return; 
			case ScenePackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case ScenePackage.SCENE:
				sequence_Scene(context, (Scene) semanticObject); 
				return; 
			case ScenePackage.SPHERE:
				sequence_Sphere(context, (Sphere) semanticObject); 
				return; 
			case ScenePackage.TEXTURE:
				sequence_Texture(context, (Texture) semanticObject); 
				return; 
			case ScenePackage.VEC3:
				sequence_Vec3(context, (Vec3) semanticObject); 
				return; 
			case ScenePackage.WALL_ELEMENT:
				sequence_WallElement(context, (WallElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     RootElement returns Box
	 *     Model returns Box
	 *     Box returns Box
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         width=EDouble? 
	 *         height=EDouble? 
	 *         depth=EDouble? 
	 *         placement=Placement? 
	 *         physicparameters=PhysicParameters? 
	 *         material=Material?
	 *     )
	 */
	protected void sequence_Box(ISerializationContext context, Box semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Material returns Color
	 *     Color returns Color
	 *
	 * Constraint:
	 *     (red=EDouble? green=EDouble? blue=EDouble? alpha=EDouble?)
	 */
	protected void sequence_Color(ISerializationContext context, Color semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns Cylinder
	 *     Model returns Cylinder
	 *     Cylinder returns Cylinder
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         radius=EDouble? 
	 *         height=EDouble? 
	 *         placement=Placement? 
	 *         physicparameters=PhysicParameters? 
	 *         material=Material?
	 *     )
	 */
	protected void sequence_Cylinder(ISerializationContext context, Cylinder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns ExternalModel
	 *     Model returns ExternalModel
	 *     ExternalModel returns ExternalModel
	 *
	 * Constraint:
	 *     (name=EString path=EString? placement=Placement?)
	 */
	protected void sequence_ExternalModel(ISerializationContext context, ExternalModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns Floor
	 *     Model returns Floor
	 *     Floor returns Floor
	 *
	 * Constraint:
	 *     (name=EString placement=Placement? physicparameters=PhysicParameters? material=Material?)
	 */
	protected void sequence_Floor(ISerializationContext context, Floor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicParameters returns PhysicParameters
	 *
	 * Constraint:
	 *     mass=EDouble?
	 */
	protected void sequence_PhysicParameters(ISerializationContext context, PhysicParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Placement returns Placement
	 *
	 * Constraint:
	 *     (position=Vec3? rotation=Rotation?)
	 */
	protected void sequence_Placement(ISerializationContext context, Placement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     (roll=EDouble? pitch=EDouble? yaw=EDouble?)
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns Scene
	 *     Scene returns Scene
	 *
	 * Constraint:
	 *     (name=EString (model+=Model model+=Model*)?)
	 */
	protected void sequence_Scene(ISerializationContext context, Scene semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns Sphere
	 *     Model returns Sphere
	 *     Sphere returns Sphere
	 *
	 * Constraint:
	 *     (name=EString radius=EDouble? placement=Placement? physicparameters=PhysicParameters? material=Material?)
	 */
	protected void sequence_Sphere(ISerializationContext context, Sphere semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Material returns Texture
	 *     Texture returns Texture
	 *
	 * Constraint:
	 *     path=EString?
	 */
	protected void sequence_Texture(ISerializationContext context, Texture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Vec3 returns Vec3
	 *
	 * Constraint:
	 *     (x=EDouble? y=EDouble? z=EDouble?)
	 */
	protected void sequence_Vec3(ISerializationContext context, Vec3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootElement returns WallElement
	 *     Model returns WallElement
	 *     WallElement returns WallElement
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         width=EDouble? 
	 *         height=EDouble? 
	 *         placement=Placement? 
	 *         physicparameters=PhysicParameters? 
	 *         material=Material?
	 *     )
	 */
	protected void sequence_WallElement(ISerializationContext context, WallElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
